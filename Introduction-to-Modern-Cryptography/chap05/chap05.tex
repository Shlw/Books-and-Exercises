% !TeX encoding = UTF-8
% !TeX program = XeLaTeX
% !TeX spellcheck = LaTeX

% Author : Shlw

\documentclass[a4paper]{article}

\usepackage{amsmath,amsfonts,amssymb}
\usepackage{mathrsfs}
\usepackage{bm}
\usepackage{geometry}
\usepackage{ntheorem}
\usepackage{hyperref}
\usepackage[ruled]{algorithm2e}
\usepackage{caption,subcaption}

\geometry{left=2cm,right=2cm,top=2cm,bottom=2cm}

\def\UrlBreaks{\do\A\do\B\do\C\do\D\do\E\do\F\do\G\do\H\do\I\do\J\do\K\do\L\do\M\do\N\do\O\do\P\do\Q\do\R\do\S\do\T\do\U\do\V\do\W\do\X\do\Y\do\Z\do\[\do\\\do\]\do\^\do\_\do\`\do\a\do\b\do\c\do\d\do\e\do\f\do\g\do\h\do\i\do\j\do\k\do\l\do\m\do\n\do\o\do\p\do\q\do\r\do\s\do\t\do\u\do\v\do\w\do\x\do\y\do\z\do\0\do\1\do\2\do\3\do\4\do\5\do\6\do\7\do\8\do\9\do\.\do\@\do\\\do\/\do\!\do\_\do\|\do\;\do\>\do\]\do\)\do\,\do\?\do\'\do+\do\=\do\#}

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{proposition}{Proposition}
\newtheorem{corollary}{Corollary}
\newtheorem{claim}{Claim}
\newtheorem{conjecture}{conjecture}
\newtheorem{definition}{Definition}
\newtheorem{construction}{Construction}
\newtheorem*{proof}{Proof}
\newtheorem*{answer}{Answer}
\newtheorem*{refute}{Refute}
\newtheorem*{example}{Example}
\newtheorem*{counterexample}{Counterexample}

\newenvironment{exercise}[1]{
	\par
	\noindent\textbf{Exercise #1.}\quad
}{
	\par
	\bigskip
}

\DeclareMathAccent{\widehat}{\mathord}{largesymbols}{"62}
\DeclareMathOperator{\lequiv}{\ \Leftrightarrow\ }
\newcommand{\rawE}{\mathop{\mathbb E}}
\newcommand{\E}[1]{\mathop{\mathbb E}_{#1}}
\newcommand{\abs}[1]{\left| #1 \right|}
\newcommand{\pbra}[1]{\left( #1 \right)}
\newcommand{\cbra}[1]{\left\{ #1 \right\}}
\newcommand{\sbra}[1]{\left[ #1 \right]}
\newcommand{\bin}{\{0,1\}}
\newcommand{\Enc}{\mathrm{Enc}}
\newcommand{\Gen}{\mathrm{Gen}}
\newcommand{\Dec}{\mathrm{Dec}}
\newcommand{\Mac}{\mathrm{Mac}}
\newcommand{\Vrfy}{\mathrm{Vrfy}}
\newcommand{\PrivK}{\mathrm{PrivK}}
\newcommand{\Macforge}{\mathrm{Mac}\text{-}\mathrm{forge}}
\newcommand{\Macsforge}{\mathrm{Mac}\text{-}\mathrm{sforge}}
\newcommand{\Encforge}{\mathrm{Enc}\text{-}\mathrm{Forge}}
\newcommand{\Hashcoll}{\mathrm{Hash}\text{-}\mathrm{coll}}
\newcommand{\negl}{\mathrm{negl}}
\newcommand{\ppt}{{\sc ppt} }
\newcommand{\eav}{\mathrm{eav}}
\newcommand{\out}{\mathrm{out}}
\newcommand{\mult}{\mathrm{mult}}
\newcommand{\cpa}{\mathrm{cpa}}
\newcommand{\cca}{\mathrm{cca}}
\newcommand{\Used}{\mathrm{Used}}
\newcommand{\Asked}{\mathrm{Asked}}
\newcommand{\Acal}{\mathcal{A}}
\newcommand{\Dcal}{\mathcal{D}}
\newcommand{\Pcal}{\mathcal{P}}

\title{Exercise Set --- Chapter $5$}
\date{}

\begin{document}

\maketitle

\begin{exercise}{5.1}
\begin{definition}[Second preimage resistance]
    A hash function $\Pi=(\Gen,H)$ 
    is \emph{second preimage resistant} if for any \ppt adversary $\Acal$, there is a 
    negligible function $\negl$ such that
    $$\Pr\sbra{\mathrm{Hash\text{-}secpre}_{\Acal,\Pi}(n)=1}\leq\negl(n),$$
    where $\mathrm{Hash\text{-}secpre}_{\Acal,\Pi}(n)$ is defined as follows:
    \begin{enumerate}
        \item A key $s$ is generated by $\Gen(1^n)$ and a valid input $x'$ is picked uniformly.
        \item $\Acal$ is given $s,x'$ and outputs $x$.
        \item Output $1$ if $x\neq x'$ is a valid input and $H^s(x)=H^s(x')$; otherwise output $0$.
    \end{enumerate}
\end{definition}

\begin{definition}[Preimage resistance]
    A hash function $\Pi=(\Gen,H)$ 
    is \emph{preimage resistant} if for any \ppt adversary $\Acal$, there is a 
    negligible function $\negl$ such that
    $$\Pr\sbra{\mathrm{Hash\text{-}pre}_{\Acal,\Pi}(n)=1}\leq\negl(n),$$
    where $\mathrm{Hash\text{-}pre}_{\Acal,\Pi}(n)$ is defined as follows:
    \begin{enumerate}
        \item A key $s$ is generated by $\Gen(1^n)$ and a valid input $x'$ is picked uniformly.
        \item Let $y=H^s(x')$. $\Acal$ is given $s,y$ and outputs $x$.
        \item Output $1$ if $x$ is a valid input and $H^s(x)=y$; otherwise output $0$.
    \end{enumerate}
\end{definition}

\begin{proof}[Collision resistant $\Rightarrow$ second preimage resistant]
    Let $\Pi=(\Gen,H)$ be a collision-resistant hash function and 
    $\Acal$ be an arbitrary \ppt adversary of $\mathrm{Hash\text{-}secpre}$.
    Develop a \ppt adversary $\Acal'$ of $\Hashcoll$ as follows:
    \begin{enumerate}
        \item $\Acal'$ is given $s$. Uniformly select a valid input $x'$.
        \item Give $s,x'$ to $\Acal$ and get answer $x$.
        \item Output $x',x$.
    \end{enumerate}
    Therefore, there exists a negligible function $\negl$ such that
    $$
        \Pr\sbra{\mathrm{Hash\text{-}secpre}_{\Acal,\Pi}(n)=1}=
        \Pr\sbra{\Hashcoll_{\Acal',\Pi}(n)=1}\leq\negl(n),
    $$
    which proves the second preimage resistance of $\Pi$.
\end{proof}

\begin{proof}[Second preimage resistant $\Rightarrow$ preimage resistant]
    Assume $2^{\ell(n)-\ell'(n)}$ is a negligible function.
    Let $\Pi=(\Gen,H),H^s:\bin^{\ell'(n)}\to\bin^{\ell(n)}$ be a second-preimage-resistant hash function and 
    $\Acal$ be an arbitrary \ppt adversary of $\mathrm{Hash\text{-}pre}$.
    Develop a \ppt adversary $\Acal'$ of $\mathrm{Hash\text{-}secpre}$ as follows:
    \begin{enumerate}
        \item $\Acal'$ is given $s,x'$. 
        \item Give $s,H^s(x')$ to $\Acal$ and get answer $x$.
        \item Output $x$.
    \end{enumerate}
    Therefore, there exists a negligible function $\negl$ such that
    \begin{align*}
        \negl(n)&\geq
        \Pr\sbra{\mathrm{Hash\text{-}secpre}_{\Acal',\Pi}(n)=1}=
        \Pr\sbra{\mathrm{Hash\text{-}pre}_{\Acal,\Pi}(n)=1,x\neq x'}\\
        &=\Pr\sbra{\mathrm{Hash\text{-}pre}_{\Acal,\Pi}(n)=1}-\Pr\sbra{\Acal(s,H^s(x'))=x'}\\
        &\geq\Pr\sbra{\mathrm{Hash\text{-}pre}_{\Acal,\Pi}(n)=1}-2^{\ell(n)-\ell'(n)},
    \end{align*}
    which proves the preimage resistance of $\Pi$.
\end{proof}

\noindent\textbf{Remark:} The requirement, that $H^s$ has much more potential inputs than outputs, 
is inevitable in the second proof. If,
for example, $H^s:\bin^{n+1}\to\bin^{n}$, then construct 
$$
H^s(x)=\begin{cases}
    0x_3\cdots x_{n+1} & x_1=x_2=0\\
    1H'^s(x) & \text{otherwise},
\end{cases}
$$
where $\Pi'=(\Gen,H'),H'^s:\bin^{n+1}\to\bin^{n-1}$ is a second-preimage-resistant hash function.
It is easy to see $\Pi=(\Gen,H)$ is second preimage resistant but not preimage resistant.

On the other hand, the definition, where $\mathrm{Hash\text{-}pre}$ takes uniform $x'$ then generate $y=H^s(x')$ 
rather than picks uniform $y$, is also compulsory not only because the former one fits the definition of one-way function,
but the latter one is not obtainable from second preimage resistance. Consider $H^s:\bin^*\to\bin^n$,
$$
H^s(x)=\begin{cases}
    0x_1x_2\cdots x_{n-1} & \text{the first $\log^2 n$ bits of $x$ are $0$'s}\\
    1H'^s(x) & \text{otherwise},
\end{cases}
$$
where $\Pi'=(\Gen,H'),H'^s:\bin^*\to\bin^{n-1}$ is a second-preimage-resistant hash function.

\end{exercise}

\begin{exercise}{5.2}
    Let $\Pi_1=(\Gen_1,H_1),\Pi_2=(\Gen_2,H_2),\Pi=(\Gen,H)$.
\begin{enumerate}
\item[(a)]
    \begin{proof}
        Without loss of generality, assume $\Pi_1$ is collision resistant.
        Then for any \ppt adversary $\Acal$ of $\Pi$, develop a \ppt adversary $\Acal'$ of $\Pi_1$ as follows:
        \begin{enumerate}
            \item $\Acal'$ is given $s_1$. Generate $s_2$ by running $\Gen_2(1^n)$.
            \item Give $s_1,s_2$ to $\Acal$ and get $x,x'$.
            \item Output $x,x'$.
        \end{enumerate}
        Since $\Pi$ is collision resistant, there exists a negligible function $\negl$ such that
        $$
        \Pr\sbra{\Hashcoll_{\Acal,\Pi_1}(n)=1}=\Pr\sbra{\Hashcoll_{\Acal',\Pi}(n)=1}\leq\negl(n),
        $$
        which proves the collision resistance of $\Pi$.
    \end{proof}
\item[(b)] The analogous claim holds for second preimage resistance, but not for preimage resistance.
    \begin{proof}[Second preimage resistance]
        Without loss of generality, assume $\Pi_1$ is second preimage resistant.
        Then for any \ppt adversary $\Acal$ of $\Pi$, develop a \ppt adversary $\Acal'$ of $\Pi_1$ as follows:
        \begin{enumerate}
            \item $\Acal'$ is given $s_1,x'$. Generate $s_2$ by running $\Gen_2(1^n)$.
            \item Give $s_1,s_2,x'$ to $\Acal$ and get $x$.
            \item Output $x$.
        \end{enumerate}
        Since $\Pi$ is second preimage resistant, there exists a negligible function $\negl$ such that
        $$
        \Pr\sbra{\mathrm{Hash\text{-}secpre}_{\Acal,\Pi_1}(n)=1}
        =\Pr\sbra{\mathrm{Hash\text{-}secpre}_{\Acal',\Pi}(n)=1}\leq\negl(n),
        $$
        which proves the second preimage resistance of $\Pi$.
    \end{proof}
    \begin{counterexample}[Preimage resistance]
        Assume $\Pi_1$ is preimage resistant and $H_1^s,H_2^s:\bin^{n+1}\to\bin^n$.
        Define $H_2^s(x)=x_2x_3\cdots x_{n+1}$. Then $H^{s_1,s_2}(x)=H_1^{s_1}(x)\|x_2x_3\cdots x_{n+1}$.
        Define \ppt adversary $\Acal$ which guesses $x_1\sim\bin$ and outputs $x_1$ with second half of $y$; 
        then the successful rate is at least $1/2$.
    \end{counterexample}
\end{enumerate}
\end{exercise}

\begin{exercise}{5.3}
Let $\Pi=(\Gen,H)$ be a collision-resistant hash function.
If for any valid input $x$, $H^s(x)$ is a valid input as well, 
then $\widehat\Pi=(\Gen,\hat H)$ is collision resistant,
where $\hat H^s(x)=H^s(H^s(x))$.
\begin{proof}
    For any \ppt adversary $\widehat\Acal$ of $\widehat\Pi$, develop a \ppt adversary $\Acal$ of $\Pi$ as follows:
    \begin{enumerate}
        \item $\Acal$ is given $s$.
        \item Give $s$ to $\widehat\Acal$ and get $x,x'$.
        \item Output $x,x'$ if $H^s(x)=H^s(x')$; otherwise output $H^s(x),H^s(x')$.
    \end{enumerate}
    Therefore, there exists a negligible function $\negl$ such that 
    $$
    \Pr\sbra{\Hashcoll_{\Acal,\Pi}(n)=1}=\Pr\sbra{\Hashcoll_{\widehat\Acal,\widehat\Pi}(n)=1}\leq\negl(n),
    $$
    which proves the collision resistance of $\widehat\Pi$.
\end{proof}
\end{exercise}

\begin{exercise}{5.6}
    Let $\Pi=(\Gen,h)$ be a fixed-length collision-resistant hash function,
    the original construction be $\Pi'=(\Gen,H)$ and new construction be $\widehat\Pi=(\Gen,\hat H)$.
\begin{enumerate}
    \item[(a)] It is not collision resistant.
        \begin{counterexample}
            Let $\widetilde\Pi=(\Gen,\tilde h),\tilde h^s:\bin^{2n}\to\bin^{n}$ 
            be a fixed-length collision-resistant hash function.
            Define $h^s(x)=\tilde h^s(x)\oplus\tilde h^s(0^{2n})$. Therefore, $\Pi$ is collision resistant.
            Now construct a \ppt adversary for $\widehat\Pi$, which outputs $x=0^{n},x'=0^{2n}$. 
            It is easy to see $\hat H(x)=\hat H(x')$.
        \end{counterexample}
    \item[(b)] It is collision resistant.
        \begin{proof}
            It suffices to show a collision in $\widehat\Pi$ implies a collision in $\Pi$.
            Assume $\hat H^s(x)=\hat H^s(x'),x\neq x'$. Since the output contains $L$, $|x|=|x'|$.
            Let the padded $x$ and $x'$ be $x_1x_2\cdots x_B,x'_1x_2'\cdots x_B'$ respectively. 
            Denote $z_0=z'_0=0^n$ and for any $i\in[B]$,
            $$z_i=h^s(z_{i-1}\|x_i),z'_i=h^s(z'_{i-1}\|x'_i).$$
            Since $z_B\|L=z'_B\|L$, we have $z_B=z'_B$.
            If $z_{B-1}\|x_B\neq z'_{B-1}\|x'_B$, we have a collision for $h$;
            otherwise $z_{B-1}=z'_{B-1}$, then repeat this process.
            Since $x\neq x'$, these must exists a collision for $h$.
        \end{proof}
    \item[(c)] It is collision resistant.
        \begin{proof}
            It suffices to show a collision in $\widehat\Pi$ implies a collision in $\Pi$.
            Assume $\hat H^s(x)=\hat H^s(x'),x\neq x'$. 
            Let the padded $x$ and $x'$ be $x_1x_2\cdots x_B,x'_1x_2'\cdots x'_{B'}$ respectively;
            and $x_{B+1}=|x|,x'_{B'+1}=|x'|$. 
            Denote $z_0=x_1,z'_0=x'_1$ and for any $i\in[B+1],j\in[B'+1]$,
            $$z_i=h^s(z_{i-1}\|x_i),z'_j=h^s(z'_{j-1}\|x'_j).$$
            \begin{itemize}
                \item $|x|\neq|x'|$. We have $z_{B}\|x_{B+1}\neq z'_{B}\|x'_{B'+1}$ but
                    $h^s(z_{B}\|x_{B+1})=z_{B+1}=z'_{B'+1}=h^s(z'_{B}\|x'_{B'+1})$, which indicates a collision for $h$.
                \item $|x|=|x'|$. Then $B=B'$. If $z_{B}\|x_{B+1}\neq z'_{B}\|x'_{B+1}$, 
                    similarly we have a collision for $h$;
                    otherwise $z_{B}=z'_{B}$, then repeat this process.
                    Since $x\neq x'$, these must exists a collision for $h$.
            \end{itemize}
        \end{proof}
    \item[(d)] It is not collision resistant.
        \begin{counterexample}
            Let $\widetilde\Pi=(\Gen,\tilde h),\tilde h^s:\bin^{2n}\to\bin^{n}$ 
            be a fixed-length collision-resistant hash function.
            Define $h^s(x)=\tilde h^s(x)\oplus\tilde h^s(2n\|0^n)\oplus n$. Therefore, $\Pi$ is collision resistant.
            Now construct a \ppt adversary for $\widehat\Pi$, which outputs $x=0^{2n},x'=0^{n}$. 
            It is easy to see $\hat H(x)=\hat H(x')$.
        \end{counterexample}
\end{enumerate}
\end{exercise}

\begin{exercise}{5.10 (a)}
    Let $\Pi=(\Gen,h),h^s:\bin^{2n}\to\bin^n$ be a collision-resistant hash function 
    and $\Pi'=(\Gen,H)$ be the Merkle-Damg\aa rd transform.
    Assume $k\in\bin^n$ and develop a \ppt adversary $\Acal$ of $\Mac_{s,k}$ as follows:
    \begin{enumerate}
        \item $\Acal$ queries $m=0^n$ and gets $t^*=H^s(k\|0^n)=h^s(h^s(h^s(0^n\|k)\|0^n)\|2n)$.
        \item Output $(m,t)$, where $m=0^n\|2n$ and 
            $$t=H^s(k\|0^n\|2n)=h^s(h^s(h^s(h^s(0^n\|k)\|0^n)\|2n)\|3n)=h^s(t^*\|3n).$$
    \end{enumerate}
    Then $\Pr\sbra{\Macforge_{\Acal,\Pi'}(n)=1}=1$, which means $\Pi'$ is never a secure MAC.
\end{exercise}

\begin{exercise}{5.13}
    Let $\Pi=(\Gen,H)$ be a fixed-length collision-resistant hash function.
    Consider the non-fixed-length Merkle tree $\Pi'=(\Gen,\mathcal{MT})$, 
    for any fixed $s$ and input $x'_1,x'_2,\cdots,x'_{2t},t>1$, define $x_i=h^s(x'_{2i-1},x'_{2i}),i\in[t]$;
    then we have a natural collision
    $$
    \mathcal{MT}_t(x_1,x_2,\cdots,x_t)=
    \mathcal{MT}_t\Big(h^s(x'_1,x'_2),h^s(x'_3,x'_4),\cdots,h^s(x'_{2t-1},x'_{2t})\Big)=
    \mathcal{MT}_{2t}(x'_1,x'_2,\cdots,x'_{2t}).
    $$
\end{exercise}

\begin{exercise}{5.14}
For simplicity, assume the Merkle tree here is built upon $t$ files, where $t>1$ is some power of $2$.
\begin{itemize}
    \item[(a)]
        \begin{definition}
            Let $\Pi=(\Gen_H,\mathcal{MT}_t)$ be a selective verification scheme.
            We say $\Pi$ is secure if for any \ppt adversary $\Acal$, 
            there is a negligible function $\negl$ such that
            $$
            \Pr\sbra{\mathrm{Merkle\text{-}vrfy}_{\Acal,\Pi}(n)=1}\leq\negl(n),
            $$
            where $\mathrm{Merkle\text{-}vrfy}_{\Acal,\Pi}(n)$ is defined as follows:
            \begin{enumerate}
                \item A key $s$ is generated by $\Gen_H(1^n)$ and a position $p$ is chosen uniformly in $[t]$.
                    For any $i\in[t]$, uniformly pick $x_i\in\bin^n$.
                \item Build the Merkle tree of $x_1,\cdots,x_t$ and obtain $\mathcal{MT}_t(x_1,\cdots,x_t)$.
                \item Denote $x_p$ and its sibling as $z_1,z_2$; then denote $x_p$'s father as $u_3$ 
                    and $u_3$'s sibling as $z_3$; then $u_3$'s father is $u_4$ and $u_4$'s sibling is $z_4$. 
                    Repeat this process until reaching root. We obtain a partial tree $\Pcal$
                    consisting of $z_1,z_2,\cdots,z_{\log t+1},u_3,u_4,\cdots,u_{\log t+1}$ and root $u_{\log t+2}$.
                \item Give $s,p,x_1,\cdots,x_t$ to $\Acal$ and get $y_1,y_2,\cdots,y_{\log t+1}\in\bin^n$.
                \item Modify $\Pcal$ by replacing the value of $z_i$ with $y_i$. 
                    Then recalculate the value of $u_i$ from the bottom up.
                \item If $y_1\neq x_p$ and the hash value of $u_{\log t+2}$ equals $\mathcal{MT}_t(x_1,\cdots,x_t)$,
                    output $1$; otherwise output $0$.
            \end{enumerate}
        \end{definition}
    \item[(b)]
        \begin{construction}
            Let $\widehat\Pi=(\Gen_H,\mathcal{MT}_t)$ be a Merkle tree of input number $t$.
            Construct a selective verification scheme $\Pi=(\Gen_H,\mathcal{MT}_t)$ as follows:
            \begin{enumerate}
                \item Client prepares $t$ files $x_1,\cdots,x_t$, gets key $s$ by running $\Gen_H(1^n)$, 
                    builds the corresponding Merkle tree to obtain
                    $h:=\mathcal{MT}_t(x_1,\cdots,x_t)$,
                    and sends $s,x_1,\cdots,x_t$ to server.
                    Then client stores $s,h$ and discards $x_1,\cdots,x_t$.
                \item Whenever client wants to retrieve $x_p,p\in[t]$, the server sends 
                    $y_1,y_2,\cdots,y_{\log t+1}$ back to client. Then client checks its validity:
                    \begin{itemize}
                        \item Build a full binary tree of size $2t-1$ and 
                            name the $t$ leaves from left to right as $k_1,k_2,\cdots,k_t$.
                        \item Denote $k_p$ and its sibling as $z_1,z_2$; then denote $k_p$'s father as $u_3$ 
                            and $u_3$'s sibling as $z_3$; then $u_3$'s father is $u_4$ and $u_4$'s sibling is $z_4$. 
                            Repeat this process until reaching root. Hence, client obtains a partial tree $\Pcal$
                            consisting of $z_1,z_2,\cdots,z_{\log t+1},u_3,u_4,\cdots,u_{\log t+1}$ 
                            and root $u_{\log t+2}$.
                        \item Modify $\Pcal$ by replacing $z_i$ with $y_i$. The value of $u_i$
                            is computed from the bottom up 
                            as $H^s(l\|r)$, where $l,r$ are the value of $u_i$'s left and right child
                            respectively.
                        \item If the value of $u_{\log t+2}$ equals $h$, the client accepts $y_1$ as $x_p$; 
                            otherwise client rejects.
                    \end{itemize} 
            \end{enumerate}
        \end{construction}
    \item[(c)]
        \begin{proof}
            Assume $\Pi'=(\Gen_H,H)$ is collision resistant and $\Pi=(\Gen_H,\mathcal{MT}_t)$ is the corresponding
            selective verification scheme. To prove $\Pi$ is secure, it suffices to show a forgery
            $y_1,y_2,\cdots,y_{\log t+1}$ in $\Pi$ implies a collision in $\Pi'$. 

            Following the definition of partial tree $\Pcal$ in $\mathrm{Merkle\text{-}vrfy}$,
            for any $x\in\Pcal$, we denote $v(x)$ ($v'(x)$) as the original (modified) value of $x$, 
            $l(x),r(x)$ as the left and right child of $x$ 
            (if $x$ is not leaf). 

            Thus $y_1\neq x_p$ and $v'(u_{\log t+2})=\mathcal{MT}_t(x_1,\cdots,x_t)$.
            If 
            $$v'(l(u_{\log t+2}))\|v'(r(u_{\log t+2}))\neq v(l(u_{\log t+2}))\|v(r(u_{\log t+2})),$$
            we have a collision for $H^s$; otherwise $v(u_{\log t+1})=v'(u_{\log t+1})$, then
            consider
            $$v'(l(u_{\log t+1}))\|v'(r(u_{\log t+1}))\text{ and }v(l(u_{\log t+1}))\|v(r(u_{\log t+1})).$$
            Repeat this process until a collision is spot.
            Since $y_1\neq x_p$ (i.e., $v(z_1)\neq v'(z_1)$), a collision is inevitable.
        \end{proof}
\end{itemize}
\end{exercise}

\end{document}
