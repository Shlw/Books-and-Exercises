% !TeX encoding = UTF-8
% !TeX program = XeLaTeX
% !TeX spellcheck = LaTeX

\documentclass[a4paper]{article}

\usepackage{amsmath,amsfonts,amssymb}
\usepackage{mathrsfs}
\usepackage{bm}
\usepackage{geometry}
\usepackage{ntheorem}
\usepackage{hyperref}
\usepackage[ruled]{algorithm2e}
\usepackage{caption,subcaption}
%\usepackage{graphicx}

\geometry{left=2cm,right=2cm,top=2cm,bottom=2cm}

\def\UrlBreaks{\do\A\do\B\do\C\do\D\do\E\do\F\do\G\do\H\do\I\do\J\do\K\do\L\do\M\do\N\do\O\do\P\do\Q\do\R\do\S\do\T\do\U\do\V\do\W\do\X\do\Y\do\Z\do\[\do\\\do\]\do\^\do\_\do\`\do\a\do\b\do\c\do\d\do\e\do\f\do\g\do\h\do\i\do\j\do\k\do\l\do\m\do\n\do\o\do\p\do\q\do\r\do\s\do\t\do\u\do\v\do\w\do\x\do\y\do\z\do\0\do\1\do\2\do\3\do\4\do\5\do\6\do\7\do\8\do\9\do\.\do\@\do\\\do\/\do\!\do\_\do\|\do\;\do\>\do\]\do\)\do\,\do\?\do\'\do+\do\=\do\#}

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{proposition}{Proposition}
\newtheorem{corollary}{Corollary}
\newtheorem{claim}{Claim}
\newtheorem{conjecture}{conjecture}
\newtheorem{definition}{Definition}
\newtheorem{construction}{Construction}
\newtheorem*{proof}{Proof}
\newtheorem*{answer}{Answer}
\newtheorem*{refute}{Refute}
\newtheorem*{example}{Example}
\newtheorem*{counterexample}{Counterexample}

\newenvironment{exercise}[1]{
	\par
	\noindent\textbf{Exercise #1.}\quad
}{
	\par
	\bigskip
}


\DeclareMathAccent{\widehat}{\mathord}{largesymbols}{"62}
\newcommand{\abs}[1]{\left| #1 \right|}
\newcommand{\pbra}[1]{\left( #1 \right)}
\newcommand{\cbra}[1]{\left\{ #1 \right\}}
\newcommand{\sbra}[1]{\left[ #1 \right]}
\newcommand{\bin}{\{0,1\}}

\title{Exercise Set --- Chapter $6$}
\date{}

\begin{document}

\maketitle

\begin{exercise}{6.1}
    \begin{itemize}
    \item Logspace-uniform circuits $\subseteq$ $\mathbf{P}$-uniform circuits $=$ $\mathbf{P}$.
    \item It is possible to simulate every TM $M$ with an oblivious TM $M'$ such that $f(n,i,j)$, which represents the position
        on $n$-length input in the $i$-th tape after $j$ steps, can be computed in logarithmic space.
            Thus the construction in Theorem 6.6 can be logspace, and $\mathbf{P}$ $\subseteq$ Logspace-uniform circuits.
    \end{itemize}
\end{exercise}

\begin{exercise}{6.4}
Prove a language has logspace-uniform circuits of polynomial size iff it is in P.

The proof is similar to Theorem 6.6 ($P \subseteq P/backslash poly$).

\begin{itemize}
\item $\Rightarrow$  If $L$ has logspace-uniform circuit of $s$ size, then we can gain $size(n), type(n,i)$ and $edge(n,i,j)$, then we can compute the results of the circuit with poly$(s)$ time, i.e., $L \in P$.

\item $\Leftarrow$ Since $L$ can be simulated by an TM M in time $T(n)$ (in poly($n$)), then M can be simulated by an oblivious TM $M'$, which runs in time $T(n)^{2}$. Since  the snapshot $z_{i}$ is only related to time $T$ and $z_{i-1}$, thus we can compute $z_{i}$ in constant-sized circuit, then we have a $O(T(n))$ size circuit to compute L, and the circuit is logspace-uniform.
\end{itemize}

\end{exercise}


\begin{exercise}{6.6}
    According to Theorem 6.19, if $\textbf{NP} \subseteq \textbf{P}_{\textbf{/poly}}$, then $\textbf{PH} = \mathbf{\Sigma}_2^p$. Thus, the conclusion of Exercise 6.5 also holds with $\mathbf{PH}$ replaced by $\mathbf{\Sigma}_2^p$. Otherwise, there exists $L \in \textbf{NP}$ such that $L \not\in \textbf{P}_{\textbf{/poly}}$. Namely, the circuit complexity is $\Omega(n^k)$ for any constant $k$.
\end{exercise}

\begin{exercise}{6.14}
\textbf{Note:} Here $NC^1$ refers to log-space uniform $NC^1$, otherwise it will contain undecidable language such as $U_B=\{1^n\quad | \exists <M,x>, |<M,x>|=n, M\text{halts on input x}\}$.

\textbf{Proof:} To prove $NC^1\subset L$, it suffice to show that we can evaluate a $O(\log n)$ depth, $poly(n)$ size circuits $\mathcal{C}_n$ by using $O(\log n)$ space. The circuit is presented by the adjacent table of its nodes. Specifically, the following 3 functions can be calculated by a $\log$-space Turing machine.
\begin{itemize}
\item[(1)] Size(n): Size of $\mathcal{C_n}$.
\item[(2)] Type(n,i): the type of $i-th$ node in $\mathcal{C}_n$.
\item[(3)] Neighbour(n,i): The left child, right child, father of the $i-th$ node.
\end{itemize} 
We give the evaluation algorithm in the following box, which takes the root(the output node) as input and return   
the evaluation result, using $\log n$ space. 

%\begin{figure}
%\includegraphics[width=0.5]{NCEvaluation.png}
%\end{figure}

\begin{algorithm}[h!]
\caption{Log-Space Algorithm for Evaluating $NC^1$}
\KwData{Root of the circuit.}
\KwResult{Output of the circuit.}
p=root \# Current node\;
q=None \# Last visited node\;
s=stack() \# Store the intermediate value in the evaluation\;
\While{p.type!="Input"}{\# p.type: "Input";"And","OR"\;
p=p.left\;}
s.push(p.val)\;
\While{!s.empty()}{p=p.father\;
\If{p==None}{return s.top() \#Completed the evaluation \;}
\If{p.right.type=="Input" or P.right==q}
{\If{p.right.type=="Input"}{
s.push(p.right.val)\;
}
temp1=s.top()\;
s.pop()\;
temp2=s.top()\;
s.pop()\;
s.push(Eval(p.type,temp1,temp2))\;
q=p \# Update the last visited node\;
}
\Else{
\While{p.type!="Input"}{p=p.left\;
}
s.push(p.val)\;
}
}
\end{algorithm}


The algorithm is a modification of the Non-recursive post-order traversal. In the Non-recursive post-order traversal, the stack is used to record the unvisted nodes, thus takes $O(log n*log n)$ spaces(record one node needs $\log |\mathcal{C}_n|=O(\log n)$ bit). We circumvent this cost by using the information of the father of a node. Instead, we use the stack to store the intermediate value in the computation. In every layer, there are at least one intermidiate value. Thus the maximum usage of the stack is the depth, $O(\log n)$. The total space cost is $p,q,s$, $2*\log n+|s|=O(\log n)$.

\end{exercise}
\end{document}
